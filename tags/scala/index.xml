<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>scala on Fp-tower blog</title>
    <link>/tags/scala/</link>
    <description>Recent content in scala on Fp-tower blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en</language>
    <lastBuildDate>Mon, 30 Dec 2019 00:00:00 +0000</lastBuildDate>
    
	<atom:link href="/tags/scala/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>State of Monocle</title>
      <link>/2020-12-30-state-of-monocle/</link>
      <pubDate>Mon, 30 Dec 2019 00:00:00 +0000</pubDate>
      
      <guid>/2020-12-30-state-of-monocle/</guid>
      <description>Monocle, like many other Scala functional libraries, was inspired by Haskell. In our case, it is the Lens library by Edward Kmett and al.
In Monocle, we experimented with various optics encoding: pair of functions, Van Laarhoven, and profunctor (see LensImpl). The JVM and Haskell runtime are hugely different, and an encoding that works well in Haskell can be inefficient in Scala. For example, Haskell relies on zero cost wrapper (newtype) to effectively select typeclass instances, but we don&#39;t have an equivalent in Scala/JVM yet (opaque types may help).</description>
    </item>
    
  </channel>
</rss>